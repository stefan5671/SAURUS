function [compass_signals, compass_parameters] = compass_analysis(ambi_signals, analysis_struct)
% COMPASS_ANALYSIS The COMPASS method performing STFT and spatial analysis
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% This file is part of the COMPASS reference implementation, as described
% in the publication
%
%   Archontis Politis, Sakari Tervo, and Ville Pulkki. 2018. 
%   "COMPASS: Coding and multidirectional parameterization of ambisonic 
%   sound scenes." 
%   IEEE Int. Conf. on Acoustics, Speech and Signal Processing (ICASSP).
%
% Author:   Archontis Politis (archontis.politis@gmail.com)
% Copyright (C) 2021 - Archontis Politis & Leo McCormack
% 
% The COMPASS reference code is free software; you can redistribute it 
% and/or modify it under the terms of the GNU General Public License as 
% published by the Free Software Foundation; either version 2 of the 
% License, or (at your option) any later version.
% 
% The COMPASS reference code is distributed in the hope that it will be 
% useful, but WITHOUT ANY WARRANTY; without even the implied warranty of 
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General 
% Public License for more details.
% 
% You should have received a copy of the GNU General Public License along 
% with this program; if not, see <https://www.gnu.org/licenses/>.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% INPUT ARGUMENTS
%
% analysis_struct       % structure with time-frequency transform, spatial
%                         format parameters, and analysis parameters,
%                         generated by COMPASS_ANALYSIS_INIT.m
% ambi_signals          % [lSig x nSH] ambisonic time-domain input signals  
%                         in channel/column format, at the samplerate
%                         specified in input_struct
%
% OUTPUT ARGUMENTS
%
% compass_signals       % time-frequency transformed signals to be passed
%                         to COMPASS_DECODER along with the analyzed
%                         parameters
% compass_parameters    % analyzed spatial parameters for each block
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Initializations
hopsize = analysis_struct.hopSize;
blocksize = analysis_struct.blockSize;
inputsize = size(ambi_signals,1);
nSH = size(ambi_signals,2);
nBands = analysis_struct.nBands;
nERBands = analysis_struct.nERBands;
nFrames = analysis_struct.nFramesInBlock;
nDoas = size(analysis_struct.DOAgrid,1);
SHorderIn = sqrt(nSH)-1;

addpath('./ext-lib/afSTFT')

% STFT allocation
afSTFT(hopsize,nSH,nSH,'hybrid'); 

% Convert ambisonic signals to ACN+N3D (if in another format)
switch analysis_struct.AMBformat 
    case 1
        ambi_signals = convert_N3D_SN3D(ambi_signals,'sn2n');
    case 2
        ambi_signals = convert_N3D_FuMa(ambi_signals,'fuma2n');
        
        % FuMa only defined up to 3rd order
        if SHorderIn>3
            SHorderIn = 3;
            nSH = 16;
            ambi_signals = ambi_signals(:,1:nSH);
        end
end

% limit order of analysis if higher than the input signal order
if analysis_struct.maxSHorder>SHorderIn
    analysis_struct.SHorderPerBand(analysis_struct.SHorderPerBand>SHorderIn) = SHorderIn;
    analysis_struct.maxSHorder=SHorderIn;
end

% rotate ambisonic signals if any rotation is defined
if any(analysis_struct.rotation_ypr>0)
    ambi_signals = ambi_signals * analysis_struct.rotation_SHMtx';
end

% Pad signals to integer blocks
nBlocks = ceil(inputsize/blocksize);
ambi_signals = [ambi_signals; zeros(nBlocks*blocksize-inputsize,nSH)];

% initialize array for storing transformed signals
compass_signals = zeros(nSH, nFrames, nBands, nBlocks);

% initialize structure for storing spatial parameters
compass_parameters.diffuseness = zeros(nBands, nBlocks);
compass_parameters.nSrc = zeros(nBands,nBlocks);
compass_parameters.doa_idx = zeros(SHorderIn^2+1,nBands,nBlocks);
compass_parameters.doa_hist = zeros(nDoas,nBands);

% process loop
CxHalf = zeros(nSH,nSH,nBands,2);
startIndex = 1;
blockIndex = 1;
progress = 1;
while startIndex+blocksize <= nBlocks*blocksize
    % Print progress
    if (startIndex+blocksize)*10/inputsize > progress
        fprintf('*');
        progress=progress+1;
    end
    
    % Time-frequency transform
    TDrange = startIndex + (0:blocksize-1);
    temp = afSTFT(ambi_signals(TDrange,:)); % returns (nBands,nFrames,nChan)
    newInputFrame = permute(temp, [3 2 1]); % permute to (nChan,nFrames,nBands)
    
    % Update covariance matrix per band
    CxHalf(:,:,:,1) = CxHalf(:,:,:,2);
    parfor band = 1:nBands
        CxHalf(:,:,band,2) = newInputFrame(:,:,band) * newInputFrame(:,:,band)';
    end
    
    % Main loop over ERB band groupings
    for erband=1:nERBands-1 
        erb_bins = analysis_struct.ERBbinIdx(erband):analysis_struct.ERBbinIdx(erband+1)-1;
        order_erb = round(mean(analysis_struct.SHorderPerBand(erb_bins)));
        nSH_anl = (order_erb+1)^2;
        
        % Combine covariance matrices for this ERB band and take the EVD
        Cx_erb = sum(sum(CxHalf(:,:,erb_bins,:),4),3);
        Cx_anl = Cx_erb(1:nSH_anl,1:nSH_anl); % truncate for current analysis order
        [V,S] = sortedEig(Cx_anl);
        lambda = diag(real(S));
        
        if sum(lambda)>0
            % Source number (K) estimation
            diffuseness = shdiff(lambda);
            K_diffuseness = floor( (nSH_anl-1)*diffuseness + 1);
            K_lim = floor(nSH_anl/2); %K_lim = order_erb^2+1;
            if order_erb==1
                K_est = RAE(lambda);
            else
                K_est = RAE(lambda);
                K_est = SORTE(lambda);
            end
            K = min([K_est K_diffuseness K_lim]);
            
            % DoA estimation
            Vn = V(:,K+1:end);
            pmap = sphMUSIC(analysis_struct.SHgrid(:,1:nSH_anl).', Vn);
            est_idx = sphPeakFind(pmap, analysis_struct.DOAgrid, K);
        else
            diffuseness = 0;
            K = 1;
            est_idx = randi(nDoas,1);
        end
        
        % Store estimated parameters
        for band = erb_bins
            compass_parameters.diffuseness(band, blockIndex) = diffuseness;
            compass_parameters.nSrc(band, blockIndex) = K;
            compass_parameters.doa_idx(1:K, band, blockIndex) = est_idx;
            compass_parameters.doa_hist(est_idx, band) = compass_parameters.doa_hist(est_idx, band) + 1;
        end
    end
    
    % Store TF data to be used by the decoder(s)
    compass_signals(:,:,:,blockIndex) = newInputFrame;
    startIndex = startIndex + blocksize;
    blockIndex = blockIndex+1;
end
fprintf('\n')

% STFT destroy
afSTFT();

end
